[
    {
        "question": "Order these data structures from fastest to slowest average access time:",
        "items": ["Array", "Binary Search Tree", "Linked List", "Hash Table"],
        "correctOrder": ["Hash Table", "Array", "Binary Search Tree", "Linked List"],
        "hints": [
            {"hint1": "Hash Table: Provides constant-time average access time."},
            {"hint2": "Array: Provides constant-time average access time."},
            {"hint3": "Binary Search Tree: Provides logarithmic-time average access time."},
            {"hint4": "Linked List: Provides linear-time average access time."}
        ]
    },
    {
        "question": "Order these sorting algorithms from lowest to highest time complexity (average case):",
        "items": ["Bubble Sort", "Merge Sort", "Quick Sort", "Insertion Sort"],
        "correctOrder": ["Merge Sort", "Quick Sort", "Insertion Sort", "Bubble Sort"],
        "hints": [
            {"hint1": "Merge Sort: O(n log n) time complexity, stable, and efficient for large datasets."},
            {"hint2": "Quick Sort: O(n log n) average case, but can degrade to O(n^2) in worst case. Often faster in practice."},
            {"hint3": "Insertion Sort: O(n^2) time complexity, but efficient for small datasets or nearly sorted arrays."},
            {"hint4": "Bubble Sort: O(n^2) time complexity, least efficient among these for large datasets."},
            {"hint5": "Consider the trade-offs between time complexity, space complexity, and stability of each algorithm."},
            {"hint6": "The efficiency of these algorithms can vary based on the input data characteristics."}
        ]
    },
    {
        "question": "Order these search algorithms from fastest to slowest (average case):",
        "items": ["Linear Search", "Binary Search", "Jump Search", "Exponential Search"],
        "correctOrder": ["Binary Search", "Exponential Search", "Jump Search", "Linear Search"],
        "hints": [
            {"hint1": "Binary Search: Provides O(log n) time complexity, very efficient for sorted arrays."},
            {"hint2": "Exponential Search: O(log n) time complexity, useful for unbounded searches."},
            {"hint3": "Jump Search: O(âˆšn) time complexity, a middle ground between linear and binary search."},
            {"hint4": "Linear Search: O(n) time complexity, simple but slowest for large datasets."},
            {"hint5": "Consider the trade-offs between time complexity and implementation complexity."},
            {"hint6": "Binary and Exponential searches require sorted data, while Jump and Linear don't."}
        ]
    },
    {
        "question": "Order these data structures from least to most memory usage:",
        "items": ["Array", "Linked List", "Hash Table", "Binary Search Tree"],
        "correctOrder": ["Array", "Linked List", "Binary Search Tree", "Hash Table"],
        "hints": [
            {"hint1": "Array: Uses contiguous memory blocks, typically the most memory-efficient."},
            {"hint2": "Linked List: Requires additional memory for storing pointers. Linked List > Array in memory usage."},
            {"hint3": "Binary Search Tree: Uses memory for node values and pointers to child nodes. Binary Search Tree > Linked List in memory usage."},
            {"hint4": "Hash Table: Often requires extra space for handling collisions and maintaining load factor. Hash Table > Binary Search Tree in memory usage."},
            {"hint5": "Memory usage order: Array < Linked List < Binary Search Tree < Hash Table"}
        ]
    },
    {
        "question": "Order these operations on a Binary Search Tree from fastest to slowest (average case):",
        "items": ["Search", "Insertion", "Deletion", "Traversal"],
        "correctOrder": ["Search", "Insertion", "Deletion", "Traversal"],
        "hints": [
            {"hint1": "Search: O(log n) time complexity, efficient for locating a value in the tree."},
            {"hint2": "Insertion: O(log n) time complexity, efficient for adding a new value to the tree."},
            {"hint3": "Deletion: O(log n) time complexity, efficient for removing a value from the tree."},
            {"hint4": "Traversal: O(n) time complexity, requires visiting all nodes in the tree."},
            {"hint5": "Consider the trade-offs between time complexity and the structure of the tree."},
            {"hint6": "The efficiency of these operations can vary based on the tree's balance and the specific data characteristics."}
        ]
    },
    {
        "question": "Order these graph traversal algorithms from least to most memory usage:",
        "items": ["Depth-First Search", "Breadth-First Search", "Dijkstra's Algorithm", "A* Search"],
        "correctOrder": ["Depth-First Search", "Breadth-First Search", "Dijkstra's Algorithm", "A* Search"],
        "hints": [
            {"hint1": "Depth-First Search: Uses a stack, typically less memory than Breadth-First Search."},
            {"hint2": "Breadth-First Search: Uses a queue, typically more memory than Depth-First Search."},
            {"hint3": "Dijkstra's Algorithm: Uses a priority queue, typically more memory than A* Search."},
            {"hint4": "A* Search: Uses a priority queue, typically more memory than Dijkstra's Algorithm."},
            {"hint5": "Consider the trade-offs between memory usage and the specific data characteristics."},
            {"hint6": "The efficiency of these algorithms can vary based on the graph size and structure."}
        ]
    },
    {
        "question": "Order these data structures from least to most suitable for frequent insertions and deletions:",
        "items": ["Array", "Linked List", "Stack", "Queue"],
        "correctOrder": ["Linked List", "Stack", "Queue", "Array"],
        "hints": [
            {"hint1": "Linked List: Provides O(1) time complexity for insertions and deletions at the beginning or end."},
            {"hint2": "Stack: Provides O(1) time complexity for insertions and deletions at the top."},
            {"hint3": "Queue: Provides O(1) time complexity for insertions at the end and deletions at the beginning."},
            {"hint4": "Array: Provides O(n) time complexity for insertions and deletions at any position."},
            {"hint5": "Consider the trade-offs between time complexity and the specific data characteristics."},
            {"hint6": "The efficiency of these operations can vary based on the data size and the specific requirements of the application."}
        ]
    },
    {
        "question": "Order these steps to implement a binary search algorithm correctly:",
        "items": [
            "Compare the target value to the middle element",
            "If the target value is found, return its index",
            "If the array is empty, return -1",
            "If the target is less than the middle, search the left half",
            "If the target is greater than the middle, search the right half",
            "Calculate the middle index of the current search range"
        ],
        "correctOrder": [
            "If the array is empty, return -1",
            "Calculate the middle index of the current search range",
            "Compare the target value to the middle element",
            "If the target value is found, return its index",
            "If the target is less than the middle, search the left half",
            "If the target is greater than the middle, search the right half"
        ],
        "hints": [
            {"hint1": "Start by handling the base case of an empty array."},
            {"hint2": "The middle index is crucial for dividing the search space."},
            {"hint3": "Comparing with the middle element determines the next step."},
            {"hint4": "If the target is found, you can immediately return its index."},
            {"hint5": "The algorithm continues by narrowing down the search range."},
            {"hint6": "Remember, binary search is a divide-and-conquer algorithm."}
        ]
    },
    {
        "question": "Order these steps to implement a binary tree correctly:",
        "items": [
            "Create a Node class with value, left, and right properties",
            "Implement methods for inserting new nodes",
            "Create a Tree class with a root property",
            "Implement traversal methods (e.g., in-order, pre-order, post-order)",
            "Initialize the root as null in the Tree constructor",
            "Implement methods for searching and deleting nodes"
        ],
        "correctOrder": [
            "Create a Node class with value, left, and right properties",
            "Create a Tree class with a root property",
            "Initialize the root as null in the Tree constructor",
            "Implement methods for inserting new nodes",
            "Implement traversal methods (e.g., in-order, pre-order, post-order)",
            "Implement methods for searching and deleting nodes"
        ],
        "hints": [
            {"hint1": "Start with the basic building block of a binary tree."},
            {"hint2": "The Tree class will manage the overall structure."},
            {"hint3": "An empty tree starts with a null root."},
            {"hint4": "Insertion is fundamental for building the tree."},
            {"hint5": "Traversal methods allow you to visit nodes in specific orders."},
            {"hint6": "Searching and deleting are more complex operations to implement last."}
        ]
    },
    {
        "question": "Rearrange these lines to implement a correct binary search function in C++:",
        "items": [
            "    if (left > right) return -1;",
            "    if (arr[mid] == target) return mid;",
            "    int mid = left + (right - left) / 2;",
            "    else if (arr[mid] < target) return binarySearch(arr, mid + 1, right, target);",
            "int binarySearch(int arr[], int left, int right, int target) {",
            "    else return binarySearch(arr, left, mid - 1, target);",
            "}",
            "int main() {",
            "    int arr[] = {2, 3, 4, 10, 40};",
            "    int n = sizeof(arr) / sizeof(arr[0]);",
            "    int target = 10;",
            "    int result = binarySearch(arr, 0, n - 1, target);",
            "    (result == -1) ? cout << \"Element not found\" : cout << \"Element found at index \" << result;",
            "    return 0;",
            "}"
        ],
        "correctOrder": [
            "int binarySearch(int arr[], int left, int right, int target) {",
            "    if (left > right) return -1;",
            "    int mid = left + (right - left) / 2;",
            "    if (arr[mid] == target) return mid;",
            "    else if (arr[mid] < target) return binarySearch(arr, mid + 1, right, target);",
            "    else return binarySearch(arr, left, mid - 1, target);",
            "}",
            "int main() {",
            "    int arr[] = {2, 3, 4, 10, 40};",
            "    int n = sizeof(arr) / sizeof(arr[0]);",
            "    int target = 10;",
            "    int result = binarySearch(arr, 0, n - 1, target);",
            "    (result == -1) ? cout << \"Element not found\" : cout << \"Element found at index \" << result;",
            "    return 0;",
            "}"
        ],
        "hints": [
            {"hint1": "Start with the function declaration for binary search."},
            {"hint2": "Handle the base case when the search range is empty."},
            {"hint3": "Calculate the middle index to divide the search space."},
            {"hint4": "Check if the middle element is the target."},
            {"hint5": "If the target is greater, search the right half."},
            {"hint6": "If the target is smaller, search the left half."},
            {"hint7": "Don't forget to close the binary search function."},
            {"hint8": "In main(), set up the test array and target."},
            {"hint9": "Call the binary search function with appropriate arguments."},
            {"hint10": "Print the result of the search."}
        ]
    },
    {
        "question": "Order these steps to implement a quicksort algorithm correctly:",
        "items": [
            "Choose a pivot element from the array",
            "Recursively apply the algorithm to the left and right subarrays",
            "Partition the array around the pivot",
            "Return the sorted array",
            "If the array has less than two elements, return",
            "Move elements smaller than the pivot to its left, and larger to its right"
        ],
        "correctOrder": [
            "If the array has less than two elements, return",
            "Choose a pivot element from the array",
            "Partition the array around the pivot",
            "Move elements smaller than the pivot to its left, and larger to its right",
            "Recursively apply the algorithm to the left and right subarrays",
            "Return the sorted array"
        ],
        "hints": [
            {"hint1": "Start with the base case for recursion."},
            {"hint2": "Selecting a good pivot is crucial for efficiency."},
            {"hint3": "Partitioning is the key operation in quicksort."},
            {"hint4": "Rearranging elements around the pivot creates two subarrays."},
            {"hint5": "The algorithm is applied recursively to smaller parts."},
            {"hint6": "After all recursive calls, the array is fully sorted."}
        ]
    },
    {
        "question": "Arrange these steps to implement a depth-first search (DFS) on a graph:",
        "items": [
            "Mark the current node as visited",
            "Create a stack (or use recursion)",
            "Pop a vertex from the stack",
            "If the stack is empty, the search is complete",
            "Push unvisited adjacent vertices onto the stack",
            "Start with the initial node"
        ],
        "correctOrder": [
            "Create a stack (or use recursion)",
            "Start with the initial node",
            "Mark the current node as visited",
            "Push unvisited adjacent vertices onto the stack",
            "Pop a vertex from the stack",
            "If the stack is empty, the search is complete"
        ],
        "hints": [
            {"hint1": "DFS uses a stack or recursion for its traversal."},
            {"hint2": "Begin the search from a specified starting point."},
            {"hint3": "Keep track of visited nodes to avoid cycles."},
            {"hint4": "Explore deeper by adding adjacent nodes to visit."},
            {"hint5": "Process nodes in a last-in, first-out order."},
            {"hint6": "The algorithm terminates when all reachable nodes are visited."}
        ]
    },
    {
        "question": "Order these steps to implement a merge sort algorithm:",
        "items": [
            "Recursively sort the right half of the array",
            "Divide the unsorted array into n subarrays, each containing one element",
            "Merge the two sorted halves",
            "Recursively sort the left half of the array",
            "Compare elements of subarrays and place them in the correct position",
            "Repeatedly merge subarrays to produce new sorted subarrays"
        ],
        "correctOrder": [
            "Divide the unsorted array into n subarrays, each containing one element",
            "Recursively sort the left half of the array",
            "Recursively sort the right half of the array",
            "Merge the two sorted halves",
            "Compare elements of subarrays and place them in the correct position",
            "Repeatedly merge subarrays to produce new sorted subarrays"
        ],
        "hints": [
            {"hint1": "Start by breaking down the problem into smallest units."},
            {"hint2": "Apply the algorithm to the first half of the data."},
            {"hint3": "Then apply the algorithm to the second half."},
            {"hint4": "Combining sorted parts is a key step in merge sort."},
            {"hint5": "Merging involves comparing and ordering elements."},
            {"hint6": "The process continues until the entire array is sorted."}
        ]
    },
    {
        "question": "Arrange these steps to implement a breadth-first search (BFS) on a graph:",
        "items": [
            "Dequeue a vertex from the queue",
            "Mark the current node as visited",
            "Create a queue for BFS",
            "Enqueue all unvisited neighbors of the current vertex",
            "Start with the initial node",
            "If the queue is empty, the search is complete"
        ],
        "correctOrder": [
            "Create a queue for BFS",
            "Start with the initial node",
            "Mark the current node as visited",
            "Enqueue all unvisited neighbors of the current vertex",
            "Dequeue a vertex from the queue",
            "If the queue is empty, the search is complete"
        ],
        "hints": [
            {"hint1": "BFS uses a queue for its traversal."},
            {"hint2": "Begin the search from a specified starting point."},
            {"hint3": "Keep track of visited nodes to avoid cycles."},
            {"hint4": "Add adjacent nodes to visit in order."},
            {"hint5": "Process nodes in a first-in, first-out order."},
            {"hint6": "The algorithm terminates when all reachable nodes are visited."}
        ]
    },
    {
        "question": "Order these steps to implement a hash table with chaining for collision resolution:",
        "items": [
            "Create an array of linked lists",
            "To insert, hash the key and add the key-value pair to the corresponding linked list",
            "Define a hash function",
            "To search, hash the key and traverse the corresponding linked list",
            "Initialize the array with empty linked lists",
            "Handle collisions by adding to the same linked list"
        ],
        "correctOrder": [
            "Define a hash function",
            "Create an array of linked lists",
            "Initialize the array with empty linked lists",
            "To insert, hash the key and add the key-value pair to the corresponding linked list",
            "Handle collisions by adding to the same linked list",
            "To search, hash the key and traverse the corresponding linked list"
        ],
        "hints": [
            {"hint1": "The hash function is crucial for distributing keys."},
            {"hint2": "The main structure combines arrays and linked lists."},
            {"hint3": "Start with an empty table structure."},
            {"hint4": "Insertion involves finding the right bucket and adding the item."},
            {"hint5": "Chaining allows multiple items in the same bucket."},
            {"hint6": "Searching follows a similar process to insertion."}
        ]
    },
    {
        "question": "Arrange these steps to implement a basic trie (prefix tree) data structure:",
        "items": [
            "Create a TrieNode class with children nodes and isEndOfWord flag",
            "To insert a word, traverse the trie, creating new nodes as needed",
            "Initialize the root node",
            "Mark the last node as end of word",
            "To search, traverse the trie following the word's characters",
            "Create a Trie class with a root TrieNode"
        ],
        "correctOrder": [
            "Create a TrieNode class with children nodes and isEndOfWord flag",
            "Create a Trie class with a root TrieNode",
            "Initialize the root node",
            "To insert a word, traverse the trie, creating new nodes as needed",
            "Mark the last node as end of word",
            "To search, traverse the trie following the word's characters"
        ],
        "hints": [
            {"hint1": "Start with the basic building block of the trie."},
            {"hint2": "The main class will manage the overall structure."},
            {"hint3": "Begin with an empty trie containing just a root."},
            {"hint4": "Insertion builds the trie structure."},
            {"hint5": "Marking word endings is crucial for distinguishing complete words."},
            {"hint6": "Searching follows a similar path to insertion."}
        ]
    },
    {
    "question": "Rearrange these lines to implement a correct merge sort function in Python:",
    "items": [
        "    if len(arr) > 1:",
        "        mid = len(arr) // 2",
        "        L = arr[:mid]",
        "        R = arr[mid:]",
        "        mergeSort(L)",
        "        mergeSort(R)",
        "        i = j = k = 0",
        "        while i < len(L) and j < len(R):",
        "            if L[i] < R[j]:",
        "                arr[k] = L[i]",
        "                i += 1",
        "            else:",
        "                arr[k] = R[j]",
        "                j += 1",
        "            k += 1",
        "        while i < len(L):",
        "            arr[k] = L[i]",
        "            i += 1",
        "            k += 1",
        "        while j < len(R):",
        "            arr[k] = R[j]",
        "            j += 1",
        "            k += 1",
        "def mergeSort(arr):",
        "arr = [12, 11, 13, 5, 6, 7]",
        "mergeSort(arr)",
        "print(\"Sorted array is:\", arr)"
    ],
    "correctOrder": [
        "def mergeSort(arr):",
        "    if len(arr) > 1:",
        "        mid = len(arr) // 2",
        "        L = arr[:mid]",
        "        R = arr[mid:]",
        "        mergeSort(L)",
        "        mergeSort(R)",
        "        i = j = k = 0",
        "        while i < len(L) and j < len(R):",
        "            if L[i] < R[j]:",
        "                arr[k] = L[i]",
        "                i += 1",
        "            else:",
        "                arr[k] = R[j]",
        "                j += 1",
        "            k += 1",
        "        while i < len(L):",
        "            arr[k] = L[i]",
        "            i += 1",
        "            k += 1",
        "        while j < len(R):",
        "            arr[k] = R[j]",
        "            j += 1",
        "            k += 1",
        "arr = [12, 11, 13, 5, 6, 7]",
        "mergeSort(arr)",
        "print(\"Sorted array is:\", arr)"
    ],
    "hints": [
        {"hint1": "Start with the function definition for merge sort."},
        {"hint2": "Check if the array has more than one element."},
        {"hint3": "Find the middle point to divide the array into two halves."},
        {"hint4": "Call mergeSort recursively on the two halves."},
        {"hint5": "Merge the sorted halves back together."},
        {"hint6": "Handle the remaining elements in the left and right subarrays."},
        {"hint7": "Don't forget to test the function with an example array."}
    ]
},{
    "question": "Rearrange these lines to implement a correct quicksort function in C++:",
    "items": [
        "    if (low < high) {",
        "        int pi = partition(arr, low, high);",
        "        quickSort(arr, low, pi - 1);",
        "        quickSort(arr, pi + 1, high);",
        "    }",
        "int partition(int arr[], int low, int high) {",
        "    int pivot = arr[high];",
        "    int i = (low - 1);",
        "    for (int j = low; j <= high - 1; j++) {",
        "        if (arr[j] < pivot) {",
        "            i++;",
        "            swap(&arr[i], &arr[j]);",
        "        }",
        "    }",
        "    swap(&arr[i + 1], &arr[high]);",
        "    return (i + 1);",
        "}",
        "void quickSort(int arr[], int low, int high) {",
        "int main() {",
        "    int arr[] = {10, 7, 8, 9, 1, 5};",
        "    int n = sizeof(arr) / sizeof(arr[0]);",
        "    quickSort(arr, 0, n - 1);",
        "    cout << \"Sorted array: \";",
        "    for (int i = 0; i < n; i++)",
        "        cout << arr[i] << \" \";",
        "    return 0;",
        "}"
    ],
    "correctOrder": [
        "void quickSort(int arr[], int low, int high) {",
        "    if (low < high) {",
        "        int pi = partition(arr, low, high);",
        "        quickSort(arr, low, pi - 1);",
        "        quickSort(arr, pi + 1, high);",
        "    }",
        "}",
        "int partition(int arr[], int low, int high) {",
        "    int pivot = arr[high];",
        "    int i = (low - 1);",
        "    for (int j = low; j <= high - 1; j++) {",
        "        if (arr[j] < pivot) {",
        "            i++;",
        "            swap(&arr[i], &arr[j]);",
        "        }",
        "    }",
        "    swap(&arr[i + 1], &arr[high]);",
        "    return (i + 1);",
        "}",
        "int main() {",
        "    int arr[] = {10, 7, 8, 9, 1, 5};",
        "    int n = sizeof(arr) / sizeof(arr[0]);",
        "    quickSort(arr, 0, n - 1);",
        "    cout << \"Sorted array: \";",
        "    for (int i = 0; i < n; i++)",
        "        cout << arr[i] << \" \";",
        "    return 0;",
        "}"
    ],
    "hints": [
        {"hint1": "Start with the function definition for quicksort."},
        {"hint2": "Check if the low index is less than the high index."},
        {"hint3": "Partition the array and get the pivot index."},
        {"hint4": "Recursively apply quicksort to the left and right subarrays."},
        {"hint5": "Define the partition function to rearrange elements around the pivot."},
        {"hint6": "Swap elements to ensure the pivot is in the correct position."},
        {"hint7": "Test the quicksort function with an example array in the main function."}
    ]
},
{
    "question": "Rearrange these lines to implement a correct merge sort function in C++:",
    "items": [
        "    if (left < right) {",
        "        int mid = left + (right - left) / 2;",
        "        mergeSort(arr, left, mid);",
        "        mergeSort(arr, mid + 1, right);",
        "        merge(arr, left, mid, right);",
        "    }",
        "void merge(int arr[], int left, int mid, int right) {",
        "    int n1 = mid - left + 1;",
        "    int n2 = right - mid;",
        "    int L[n1], R[n2];",
        "    for (int i = 0; i < n1; i++)",
        "        L[i] = arr[left + i];",
        "    for (int j = 0; j < n2; j++)",
        "        R[j] = arr[mid + 1 + j];",
        "    int i = 0, j = 0, k = left;",
        "    while (i < n1 && j < n2) {",
        "        if (L[i] <= R[j]) {",
        "            arr[k] = L[i];",
        "            i++;",
        "        } else {",
        "            arr[k] = R[j];",
        "            j++;",
        "        }",
        "        k++;",
        "    }",
        "    while (i < n1) {",
        "        arr[k] = L[i];",
        "        i++;",
        "        k++;",
        "    }",
        "    while (j < n2) {",
        "        arr[k] = R[j];",
        "        j++;",
        "        k++;",
        "    }",
        "}",
        "void mergeSort(int arr[], int left, int right) {",
        "int main() {",
        "    int arr[] = {12, 11, 13, 5, 6, 7};",
        "    int arr_size = sizeof(arr) / sizeof(arr[0]);",
        "    mergeSort(arr, 0, arr_size - 1);",
        "    cout << \"Sorted array is \\n\";",
        "    for (int i = 0; i < arr_size; i++)",
        "        cout << arr[i] << \" \";",
        "    return 0;",
        "}"
    ],
    "correctOrder": [
        "void merge(int arr[], int left, int mid, int right) {",
        "    int n1 = mid - left + 1;",
        "    int n2 = right - mid;",
        "    int L[n1], R[n2];",
        "    for (int i = 0; i < n1; i++)",
        "        L[i] = arr[left + i];",
        "    for (int j = 0; j < n2; j++)",
        "        R[j] = arr[mid + 1 + j];",
        "    int i = 0, j = 0, k = left;",
        "    while (i < n1 && j < n2) {",
        "        if (L[i] <= R[j]) {",
        "            arr[k] = L[i];",
        "            i++;",
        "        } else {",
        "            arr[k] = R[j];",
        "            j++;",
        "        }",
        "        k++;",
        "    }",
        "    while (i < n1) {",
        "        arr[k] = L[i];",
        "        i++;",
        "        k++;",
        "    }",
        "    while (j < n2) {",
        "        arr[k] = R[j];",
        "        j++;",
        "        k++;",
        "    }",
        "}",
        "void mergeSort(int arr[], int left, int right) {",
        "    if (left < right) {",
        "        int mid = left + (right - left) / 2;",
        "        mergeSort(arr, left, mid);",
        "        mergeSort(arr, mid + 1, right);",
        "        merge(arr, left, mid, right);",
        "    }",
        "}",
        "int main() {",
        "    int arr[] = {12, 11, 13, 5, 6, 7};",
        "    int arr_size = sizeof(arr) / sizeof(arr[0]);",
        "    mergeSort(arr, 0, arr_size - 1);",
        "    cout << \"Sorted array is \\n\";",
        "    for (int i = 0; i < arr_size; i++)",
        "        cout << arr[i] << \" \";",
        "    return 0;",
        "}"
    ],
    "hints": [
        {"hint1": "Start with the function definition for merge."},
        {"hint2": "Initialize the left and right subarrays."},
        {"hint3": "Merge the subarrays back into the original array."},
        {"hint4": "Define the mergeSort function."},
        {"hint5": "Recursively sort the left and right halves."},
        {"hint6": "Merge the sorted halves."},
        {"hint7": "Test the mergeSort function with an example array in the main function."}
    ]
},

{
    "question": "Rearrange these lines to implement a correct depth-first search (DFS) function in C++:",
    "items": [
        "    visited[v] = true;",
        "    cout << v << \" \";",
        "    for (auto i = adj[v].begin(); i != adj[v].end(); ++i)",
        "        if (!visited[*i])",
        "            DFSUtil(*i, visited);",
        "void Graph::DFSUtil(int v, bool visited[]) {",
        "void Graph::DFS(int v) {",
        "    bool *visited = new bool[V];",
        "    for (int i = 0; i < V; i++)",
        "        visited[i] = false;",
        "    DFSUtil(v, visited);",
        "}",
        "int main() {",
        "    Graph g(4);",
        "    g.addEdge(0, 1);",
        "    g.addEdge(0, 2);",
        "    g.addEdge(1, 2);",
        "    g.addEdge(2, 0);",
        "    g.addEdge(2, 3);",
        "    g.addEdge(3, 3);",
        "    cout << \"Following is Depth First Traversal (starting from vertex 2) \\n\";",
        "    g.DFS(2);",
        "    return 0;",
        "}"
    ],
    "correctOrder": [
        "void Graph::DFSUtil(int v, bool visited[]) {",
        "    visited[v] = true;",
        "    cout << v << \" \";",
        "    for (auto i = adj[v].begin(); i != adj[v].end(); ++i)",
        "        if (!visited[*i])",
        "            DFSUtil(*i, visited);",
        "}",
        "void Graph::DFS(int v) {",
        "    bool *visited = new bool[V];",
        "    for (int i = 0; i < V; i++)",
        "        visited[i] = false;",
        "    DFSUtil(v, visited);",
        "}",
        "int main() {",
        "    Graph g(4);",
        "    g.addEdge(0, 1);",
        "    g.addEdge(0, 2);",
        "    g.addEdge(1, 2);",
        "    g.addEdge(2, 0);",
        "    g.addEdge(2, 3);",
        "    g.addEdge(3, 3);",
        "    cout << \"Following is Depth First Traversal (starting from vertex 2) \\n\";",
        "    g.DFS(2);",
        "    return 0;",
        "}"
    ],
    "hints": [
        {"hint1": "Start with the DFSUtil function definition."},
        {"hint2": "Mark the current node as visited and print it."},
        {"hint3": "Recur for all the vertices adjacent to this vertex."},
        {"hint4": "Define the DFS function."},
        {"hint5": "Initialize the visited array."},
        {"hint6": "Call the DFSUtil function."},
        {"hint7": "Test the DFS function with an example graph in the main function."}
    ]
}, {
    "question": "Rearrange these lines to implement a correct breadth-first search (BFS) function in C++:",
    "items": [
        "    bool *visited = new bool[V];",
        "    for (int i = 0; i < V; i++)",
        "        visited[i] = false;",
        "    list<int> queue;",
        "    visited[s] = true;",
        "    queue.push_back(s);",
        "    while (!queue.empty()) {",
        "        s = queue.front();",
        "        cout << s << \" \";",
        "        queue.pop_front();",
        "        for (auto i = adj[s].begin(); i != adj[s].end(); ++i) {",
        "            if (!visited[*i]) {",
        "                visited[*i] = true;",
        "                queue.push_back(*i);",
        "            }",
        "        }",
        "    }",
        "void Graph::BFS(int s) {",
        "}",
        "int main() {",
        "    Graph g(4);",
        "    g.addEdge(0, 1);",
        "    g.addEdge(0, 2);",
        "    g.addEdge(1, 2);",
        "    g.addEdge(2, 0);",
        "    g.addEdge(2, 3);",
        "    g.addEdge(3, 3);",
        "    cout << \"Following is Breadth First Traversal (starting from vertex 2) \\n\";",
        "    g.BFS(2);",
        "    return 0;",
        "}"
    ],
    "correctOrder": [
        "void Graph::BFS(int s) {",
        "    bool *visited = new bool[V];",
        "    for (int i = 0; i < V; i++)",
        "        visited[i] = false;",
        "    list<int> queue;",
        "    visited[s] = true;",
        "    queue.push_back(s);",
        "    while (!queue.empty()) {",
        "        s = queue.front();",
        "        cout << s << \" \";",
        "        queue.pop_front();",
        "        for (auto i = adj[s].begin(); i != adj[s].end(); ++i) {",
        "            if (!visited[*i]) {",
        "                visited[*i] = true;",
        "                queue.push_back(*i);",
        "            }",
        "        }",
        "    }",
        "}",
        "int main() {",
        "    Graph g(4);",
        "    g.addEdge(0, 1);",
        "    g.addEdge(0, 2);",
        "    g.addEdge(1, 2);",
        "    g.addEdge(2, 0);",
        "    g.addEdge(2, 3);",
        "    g.addEdge(3, 3);",
        "    cout << \"Following is Breadth First Traversal (starting from vertex 2) \\n\";",
        "    g.BFS(2);",
        "    return 0;",
        "}"
    ],
    "hints": [
        {"hint1": "Start with the BFS function definition."},
        {"hint2": "Initialize the visited array."},
        {"hint3": "Create a queue for BFS."},
        {"hint4": "Mark the current node as visited and enqueue it."},
        {"hint5": "Dequeue a vertex from the queue and print it."},
        {"hint6": "Enqueue all adjacent vertices that haven't been visited."},
        {"hint7": "Test the BFS function with an example graph in the main function."}
    ]
},

{
    "question": "Rearrange these lines to implement a correct binary search tree (BST) insertion function in C++:",
    "items": [
        "    if (root == NULL) {",
        "        root = new Node(key);",
        "        return root;",
        "    }",
        "    if (key < root->key)",
        "        root->left = insert(root->left, key);",
        "    else if (key > root->key)",
        "        root->right = insert(root->right, key);",
        "    return root;",
        "Node* insert(Node* root, int key) {",
        "}",
        "int main() {",
        "    Node* root = NULL;",
        "    root = insert(root, 50);",
        "    insert(root, 30);",
        "    insert(root, 20);",
        "    insert(root, 40);",
        "    insert(root, 70);",
        "    insert(root, 60);",
        "    insert(root, 80);",
        "    cout << \"Inorder traversal of the given tree \\n\";",
        "    inorder(root);",
        "    return 0;",
        "}"
    ],
    "correctOrder": [
        "Node* insert(Node* root, int key) {",
        "    if (root == NULL) {",
        "        root = new Node(key);",
        "        return root;",
        "    }",
        "    if (key < root->key)",
        "        root->left = insert(root->left, key);",
        "    else if (key > root->key)",
        "        root->right = insert(root->right, key);",
        "    return root;",
        "}",
        "int main() {",
        "    Node* root = NULL;",
        "    root = insert(root, 50);",
        "    insert(root, 30);",
        "    insert(root, 20);",
        "    insert(root, 40);",
        "    insert(root, 70);",
        "    insert(root, 60);",
        "    insert(root, 80);",
        "    cout << \"Inorder traversal of the given tree \\n\";",
        "    inorder(root);",
        "    return 0;",
        "}"
    ],
    "hints": [
        {"hint1": "Start with the insert function definition."},
        {"hint2": "Check if the root is NULL and create a new node if it is."},
        {"hint3": "Recursively insert the key in the left or right subtree."},
        {"hint4": "Return the root node."},
        {"hint5": "Test the insert function with an example tree in the main function."}
    ]
},
{
    "question": "Rearrange these lines to implement a correct Trie (prefix tree) insertion function in C++:",
    "items": [
        "    TrieNode* pCrawl = root;",
        "    for (int i = 0; i < key.length(); i++) {",
        "        int index = key[i] - 'a';",
        "        if (!pCrawl->children[index])",
        "            pCrawl->children[index] = getNode();",
        "        pCrawl = pCrawl->children[index];",
        "    }",
        "    pCrawl->isEndOfWord = true;",
        "void insert(TrieNode* root, string key) {",
        "}",
        "int main() {",
        "    string keys[] = {\"the\", \"a\", \"there\", \"answer\", \"any\", \"by\", \"bye\", \"their\"};",
        "    int n = sizeof(keys) / sizeof(keys[0]);",
        "    TrieNode* root = getNode();",
        "    for (int i = 0; i < n; i++)",
        "        insert(root, keys[i]);",
        "    search(root, \"the\") ? cout << \"Yes\\n\" : cout << \"No\\n\";",
        "    search(root, \"these\") ? cout << \"Yes\\n\" : cout << \"No\\n\";",
        "    return 0;",
        "}"
    ],
    "correctOrder": [
        "void insert(TrieNode* root, string key) {",
        "    TrieNode* pCrawl = root;",
        "    for (int i = 0; i < key.length(); i++) {",
        "        int index = key[i] - 'a';",
        "        if (!pCrawl->children[index])",
        "            pCrawl->children[index] = getNode();",
        "        pCrawl = pCrawl->children[index];",
        "    }",
        "    pCrawl->isEndOfWord = true;",
        "}",
        "int main() {",
        "    string keys[] = {\"the\", \"a\", \"there\", \"answer\", \"any\", \"by\", \"bye\", \"their\"};",
        "    int n = sizeof(keys) / sizeof(keys[0]);",
        "    TrieNode* root = getNode();",
        "    for (int i = 0; i < n; i++)",
        "        insert(root, keys[i]);",
        "    search(root, \"the\") ? cout << \"Yes\\n\" : cout << \"No\\n\";",
        "    search(root, \"these\") ? cout << \"Yes\\n\" : cout << \"No\\n\";",
        "    return 0;",
        "}"
    ],
    "hints": [
        {"hint1": "Start with the insert function definition."},
        {"hint2": "Initialize the current node as the root."},
        {"hint3": "Iterate through each character of the key."},
        {"hint4": "Create a new node if the character is not present."},
        {"hint5": "Move to the child node corresponding to the character."},
        {"hint6": "Mark the end of the word after inserting all characters."},
        {"hint7": "Test the insert function with an example set of keys in the main function."}
    ]
},
{
    "question": "Rearrange these lines to implement a correct hash table with chaining in C++:",
    "items": [
        "    int index = hashFunction(key);",
        "    table[index].push_back(key);",
        "void HashTable::insertItem(int key) {",
        "}",
        "int HashTable::hashFunction(int key) {",
        "    return (key % BUCKET);",
        "}",
        "int main() {",
        "    int a[] = {15, 11, 27, 8, 12};",
        "    int n = sizeof(a) / sizeof(a[0]);",
        "    HashTable h(7);",
        "    for (int i = 0; i < n; i++)",
        "        h.insertItem(a[i]);",
        "    h.displayHash();",
        "    return 0;",
        "}"
    ],
    "correctOrder": [
        "void HashTable::insertItem(int key) {",
        "    int index = hashFunction(key);",
        "    table[index].push_back(key);",
        "}",
        "int HashTable::hashFunction(int key) {",
        "    return (key % BUCKET);",
        "}",
        "int main() {",
        "    int a[] = {15, 11, 27, 8, 12};",
        "    int n = sizeof(a) / sizeof(a[0]);",
        "    HashTable h(7);",
        "    for (int i = 0; i < n; i++)",
        "        h.insertItem(a[i]);",
        "    h.displayHash();",
        "    return 0;",
        "}"
    ],
    "hints": [
        {"hint1": "Start with the insertItem function definition."},
        {"hint2": "Compute the hash index using the hash function."},
        {"hint3": "Insert the key into the linked list at the computed index."},
        {"hint4": "Define the hash function."},
        {"hint5": "Test the hash table with an example set of keys in the main function."}
    ]
},
{
    "question": "Rearrange these lines to implement a correct Dijkstra's algorithm in C++:",
    "items": [
        "    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
        "    vector<int> dist(V, INF);",
        "    pq.push(make_pair(0, src));",
        "    dist[src] = 0;",
        "    while (!pq.empty()) {",
        "        int u = pq.top().second;",
        "        pq.pop();",
        "        for (auto x : adj[u]) {",
        "            int v = x.first;",
        "            int weight = x.second;",
        "            if (dist[v] > dist[u] + weight) {",
        "                dist[v] = dist[u] + weight;",
        "                pq.push(make_pair(dist[v], v));",
        "            }",
        "        }",
        "    }",
        "    for (int i = 0; i < V; ++i)",
        "        cout << i << \" \\t\\t\" << dist[i] << endl;",
        "void Graph::dijkstra(int src) {",
        "}",
        "int main() {",
        "    int V = 9;",
        "    Graph g(V);",
        "    g.addEdge(0, 1, 4);",
        "    g.addEdge(0, 7, 8);",
        "    g.addEdge(1, 2, 8);",
        "    g.addEdge(1, 7, 11);",
        "    g.addEdge(2, 3, 7);",
        "    g.addEdge(2, 8, 2);",
        "    g.addEdge(2, 5, 4);",
        "    g.addEdge(3, 4, 9);",
        "    g.addEdge(3, 5, 14);",
        "    g.addEdge(4, 5, 10);",
        "    g.addEdge(5, 6, 2);",
        "    g.addEdge(6, 7, 1);",
        "    g.addEdge(6, 8, 6);",
        "    g.addEdge(7, 8, 7);",
        "    g.dijkstra(0);",
        "    return 0;",
        "}"
    ],
    "correctOrder": [
        "void Graph::dijkstra(int src) {",
        "    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
        "    vector<int> dist(V, INF);",
        "    pq.push(make_pair(0, src));",
        "    dist[src] = 0;",
        "    while (!pq.empty()) {",
        "        int u = pq.top().second;",
        "        pq.pop();",
        "        for (auto x : adj[u]) {",
        "            int v = x.first;",
        "            int weight = x.second;",
        "            if (dist[v] > dist[u] + weight) {",
        "                dist[v] = dist[u] + weight;",
        "                pq.push(make_pair(dist[v], v));",
        "            }",
        "        }",
        "    }",
        "    for (int i = 0; i < V; ++i)",
        "        cout << i << \" \\t\\t\" << dist[i] << endl;",
        "}",
        "int main() {",
        "    int V = 9;",
        "    Graph g(V);",
        "    g.addEdge(0, 1, 4);",
        "    g.addEdge(0, 7, 8);",
        "    g.addEdge(1, 2, 8);",
        "    g.addEdge(1, 7, 11);",
        "    g.addEdge(2, 3, 7);",
        "    g.addEdge(2, 8, 2);",
        "    g.addEdge(2, 5, 4);",
        "    g.addEdge(3, 4, 9);",
        "    g.addEdge(3, 5, 14);",
        "    g.addEdge(4, 5, 10);",
        "    g.addEdge(5, 6, 2);",
        "    g.addEdge(6, 7, 1);",
        "    g.addEdge(6, 8, 6);",
        "    g.addEdge(7, 8, 7);",
        "    g.dijkstra(0);",
        "    return 0;",
        "}"
    ],
    "hints": [
        {"hint1": "Start with the dijkstra function definition."},
        {"hint2": "Initialize the priority queue and distance vector."},
        {"hint3": "Push the source node into the priority queue."},
        {"hint4": "Update the distances of adjacent vertices."},
        {"hint5": "Print the shortest distances from the source to all vertices."},
        {"hint6": "Test the dijkstra function with an example graph in the main function."}
    ]
}

]